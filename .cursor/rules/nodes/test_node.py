import os
import re
import json
import uuid
import subprocess

"""
Production-grade test node for Flutter projects.
- Writes code under project_root/output_dir
- Ensures valid Dart file by wrapping bare widget snippets
- Runs formatter, then analyzer with robust fallbacks
"""

WRAPPER_TEMPLATE = """
import 'package:flutter/material.dart';

// AUTO-GENERATED BY FSM. DO NOT EDIT BY HAND.
class GeneratedWidget extends StatelessWidget {
  const GeneratedWidget({super.key});

  @override
  Widget build(BuildContext context) {
    return {WIDGET_CODE};
  }
}
"""

def _run_cmd(cmd, cwd, env=None):
    res = subprocess.run(
        cmd,
        cwd=cwd,
        capture_output=True,
        text=True,
        env=env,
    )
    return res.returncode, res.stdout, res.stderr

def _looks_like_full_dart(source: str) -> bool:
    # crude heuristics: has import + class or main
    s = source.strip()
    return ("import 'package:flutter" in s) and ("class " in s or "void main(" in s)

def _wrap_if_needed(source: str) -> str:
    # If it's just a widget expression (e.g., `Container(...)`) wrap it
    snippet = source.strip().rstrip(';')
    if _looks_like_full_dart(snippet):
        return snippet

    # If user provided a build() method or a class, keep as-is
    if re.search(r"class\s+\w+\s+extends\s+(StatelessWidget|StatefulWidget)", snippet):
        return snippet

    # Otherwise, assume it's a widget expression and wrap
    wrapped = WRAPPER_TEMPLATE.replace('{WIDGET_CODE}', snippet)
    return wrapped

def test_code(code: str, project_root="/Users/caglarilhan/psyclinicai") -> tuple[bool, str]:
    try:
        # Load config
        with open("fsm_config_project.json", "r", encoding="utf-8") as f:
            cfg = json.load(f)

        project_root = cfg["project_root"]
        out_dir = os.path.join(project_root, cfg["output_dir"])  # e.g., lib/widgets/generated
        os.makedirs(out_dir, exist_ok=True)

        filename = f"{cfg.get('file_prefix','fsm_gen_')}{uuid.uuid4().hex[:8]}.dart"
        fpath = os.path.join(out_dir, filename)

        # Normalize/Wrap code to a valid, analyzable Dart file
        final_source = _wrap_if_needed(code)

        with open(fpath, "w", encoding="utf-8") as f:
            f.write(final_source)
        print(f"💾 Kod dosyaya yazıldı: {fpath}")

        # UTF-8 locale to avoid macOS encoding quirks
        env = os.environ.copy()
        env.setdefault("LC_ALL", "en_US.UTF-8")
        env.setdefault("LANG", "en_US.UTF-8")

        # 1) Format (non-fatal)
        rc_fmt, out_fmt, err_fmt = _run_cmd(["dart", "format", "lib"], cwd=project_root, env=env)
        print(f"🔧 Dart format: rc={rc_fmt}")

        # 2) Analyze (robust fallbacks)
        # Try `flutter analyze` first, then dart analyze, then no-fatal-warnings
        cmds = [
            ["flutter", "analyze"],
            ["dart", "analyze"],
            ["dart", "analyze", "--no-fatal-warnings"],
        ]

        for cmd in cmds:
            try:
                rc, out, err = _run_cmd(cmd, cwd=project_root, env=env)
                print(f"🔍 {' '.join(cmd)}: rc={rc}")
                
                if rc == 0:
                    return True, f"✅ Test başarılı: {' '.join(cmd)}"
                elif "no-fatal-warnings" in " ".join(cmd):
                    # Sadece warning'ler varsa kabul et
                    if "error" not in err.lower():
                        return True, f"⚠️ Test geçti (sadece warning): {' '.join(cmd)}"
                        
            except Exception as e:
                print(f"💥 {cmd} hatası: {e}")
                continue

        return False, "❌ Tüm analyzer'lar başarısız"
        
    except Exception as e:
        return False, f"❌ Test hatası: {e}" 